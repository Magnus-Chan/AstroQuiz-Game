<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Evolution Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #e0f2f7; /* Light blue-gray for general text */
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        canvas {
            border: 2px solid #333;
            display: block;
            background: radial-gradient(circle, #001122 0%, #000000 100%);
            border-radius: 10px; /* Rounded corners for canvas */
            box-shadow: 0 0 30px rgba(0, 170, 255, 0.3); /* Soft blue glow */
        }

        .ui, .controls, .info-panel {
            position: absolute;
            background: rgba(0,0,0,0.85); /* Slightly darker, more opaque background */
            padding: 15px 20px;
            border-radius: 15px; /* More rounded corners */
            border: 1px solid #00aaff; /* Blue border */
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.4); /* Matching blue glow */
            color: #e0f2f7;
            font-size: 16px;
            z-index: 10; /* Ensure UI is above canvas */
        }

        .ui {
            top: 20px;
            left: 20px;
            min-width: 200px;
        }

        .controls {
            bottom: 20px;
            left: 20px;
            font-size: 14px;
            padding: 10px 15px;
        }

        .info-panel {
            top: 20px;
            right: 20px;
            max-width: 350px;
            font-size: 15px;
            line-height: 1.5;
        }

        .stage-indicator {
            color: #7affd4; /* Teal color for stage indicator */
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .progress-bar {
            width: 220px; /* Slightly wider progress bar */
            height: 12px; /* Taller progress bar */
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            margin: 8px 0;
            border: 1px solid #555;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffff44, #44ff44);
            transition: width 0.5s ease-out; /* Smoother transition */
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85); /* Darker, more opaque background for modal */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden; /* Hidden by default */
            opacity: 0;
            transition: visibility 0s, opacity 0.4s ease-in-out;
        }

        .modal-overlay.active {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background: #1a1a2e; /* Dark blue background */
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00aaff; /* Blue border */
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 170, 255, 0.7); /* Stronger blue glow */
            max-width: 650px;
            color: #e0f2f7; /* Light text color */
            animation: fadeInScale 0.4s ease-out;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-content h3 {
            margin-bottom: 25px;
            color: #7affd4; /* Teal color for question */
            font-size: 1.7em; /* Larger font for question */
            line-height: 1.4;
        }

        .options-container button {
            display: block;
            width: 90%; /* Wider buttons */
            padding: 15px 25px; /* Larger padding */
            margin: 18px auto; /* More margin between buttons */
            background: #004d66; /* Darker blue button */
            color: #e0f2f7;
            border: 1px solid #00aaff;
            border-radius: 10px; /* More rounded buttons */
            cursor: pointer;
            font-size: 1.2em; /* Larger font for options */
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 5px #002b3d; /* Button shadow */
        }

        .options-container button:hover {
            background: #006680;
            transform: translateY(-3px);
            box-shadow: 0 8px #003a52;
        }

        .options-container button:active {
            transform: translateY(1px);
            box-shadow: 0 2px #001a26;
        }

        .options-container button.correct {
            background: #28a745; /* Green for correct */
            border-color: #218838;
            box-shadow: 0 5px #1c6b2f;
        }

        .options-container button.incorrect {
            background: #dc3545; /* Red for incorrect */
            border-color: #c82333;
            box-shadow: 0 5px #a7232e;
        }

        .feedback-message {
            margin-top: 30px; /* More space above feedback */
            font-weight: bold;
            font-size: 1.5em; /* Larger font for feedback */
        }

        .feedback-message.correct-feedback {
            color: #28a745; /* Green feedback */
        }

        .feedback-message.incorrect-feedback {
            color: #dc3545; /* Red feedback */
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
<canvas id="gameCanvas" width="1000" height="700"></canvas>

<div class="ui">
    <div>Score: <span id="score">0</span></div>
    <div>Elements Collected: <span id="elements">0</span></div>
    <div>Stage: <span id="currentStage">Molecular Cloud</span></div>
    <div class="progress-bar">
        <div class="progress-fill" id="stageProgress" style="width: 0%"></div>
    </div>
</div>

<div class="controls">
    <div>Controls: WASD or Arrow Keys to move</div>
    <div>Collect elements • Avoid dangers • Learn stellar evolution!</div>
</div>

<div class="info-panel">
    <div class="stage-indicator" id="stageTitle">Molecular Cloud Formation</div>
    <div id="stageDescription">Navigate through the gas and dust cloud where stars are born. Collect hydrogen and helium while avoiding cosmic debris!</div>
</div>

<!-- Question Modal -->
<div id="questionModal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="questionText"></h3>
        <div id="answerOptions" class="options-container">
            <!-- Buttons will be injected here by JavaScript -->
        </div>
        <p id="feedbackText" class="feedback-message"></p>
    </div>
</div>

<!-- Game Over Modal -->
<div id="gameOverModal" class="modal-overlay">
    <div class="modal-content">
        <h3>GAME OVER!</h3>
        <p>The Black Hole has consumed everything.</p>
        <p>Your final score: <span id="finalScore">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game state
    let gameState = {
        score: 0,
        elements: 0,
        currentStage: 0,
        stageProgress: 0,
        player: {
            x: 100,
            y: canvas.height / 2,
            width: 40, // Increased width for better drawing
            height: 30, // Increased height
            speed: 3.5, // Slightly lowered player speed
            angle: 0
        },
        particles: [],
        collectibles: [],
        obstacles: [],
        stars: [], // These are the small background twinkly stars
        starEvolutionStage: 0, // 0: Nebula, 1: Main Sequence, 2: Red Giant, 3: Supernova, 4: Black Hole
        supernovaFlashTimer: 0, // Used for supernova animation
        blackHoleRotation: 0, // For black hole accretion disk animation
        lastStarEvolutionScoreTier: -1 // Tracks the last score multiple of 50 for star evolution
    };

    // Game control flags
    let gamePaused = false;

    // Stellar evolution stages for the main game progression (UI text)
    const stages = [
        {
            name: "Molecular Cloud",
            title: "Molecular Cloud Formation",
            description: "Navigate through the gas and dust cloud where stars are born. Collect hydrogen and helium while avoiding cosmic debris!",
            duration: 300,
            backgroundColor: "#001122",
            starColor: "#444466"
        },
        {
            name: "Protostar",
            title: "Protostar Collapse",
            description: "Gravity is pulling matter together! Help guide the formation process while collecting more hydrogen for future fusion.",
            duration: 250,
            backgroundColor: "#221100",
            starColor: "#664422"
        },
        {
            name: "Main Sequence",
            title: "Main Sequence (Hydrogen Fusion)",
            description: "The star is now fusing hydrogen into helium! This stable phase lasts 90% of the star's lifetime. Collect fusion products!",
            duration: 400,
            backgroundColor: "#002211",
            starColor: "#ffff44" // Brighter yellow for main sequence
        },
        {
            name: "Red Giant",
            title: "Red Giant Phase",
            description: "The core contracts while outer layers expand! Helium fusion creates carbon and oxygen. Avoid the expanding stellar winds!",
            duration: 200,
            backgroundColor: "#331100",
            starColor: "#ff6644"
        },
        {
            name: "Planetary Nebula",
            title: "Planetary Nebula",
            description: "The star sheds its outer layers, creating beautiful nebulae! Collect heavy elements being distributed into space.",
            duration: 150,
            backgroundColor: "#113322",
            starColor: "#66ffaa"
        },
        {   // This entry will be used for the Black Hole information
            name: "Black Hole",
            title: "Black Hole Expansion", // Changed from White Dwarf Cooling
            description: "The ultimate fate of massive stars! Its immense gravity pulls everything in. Survive as long as you can!", // Updated description
            duration: 200, // Duration is less relevant for the game-ending stage
            backgroundColor: "#000000", // Black for black hole
            starColor: "#ffffff" // Not applicable, but keeping a placeholder
        }
    ];

    // Quiz Questions (Expanded)
    const questions = [
        {
            question: "What is the primary process that powers a star during its main sequence phase?",
            options: ["Gravitational collapse", "Nuclear fission", "Nuclear fusion of hydrogen into helium", "Thermal expansion"],
            correctAnswerIndex: 2
        },
        {
            question: "Stars are born in what celestial structures?",
            options: ["Black holes", "Planetary nebulae", "Molecular clouds", "Supernova remnants"],
            correctAnswerIndex: 2
        },
        {
            question: "What happens when a star depletes hydrogen in its core and expands?",
            options: ["It becomes a white dwarf", "It becomes a red giant", "It undergoes a supernova", "It turns into a black hole"],
            correctAnswerIndex: 1
        },
        {
            question: "What is the final stage for low- and intermediate-mass stars after shedding their outer layers?",
            options: ["Neutron star", "Red supergiant", "White dwarf", "Black hole"],
            correctAnswerIndex: 2
        },
        {
            question: "Which element's fusion *absorbs* energy, leading to a core collapse in high-mass stars?",
            options: ["Helium", "Carbon", "Oxygen", "Iron"],
            correctAnswerIndex: 3
        },
        {
            question: "What stellar event is responsible for spreading heavy elements throughout the universe?",
            options: ["Protostar formation", "Main sequence fusion", "Planetary nebula expansion", "Supernova explosion"],
            correctAnswerIndex: 3
        },
        {
            question: "What determines the ultimate fate of a star?",
            options: ["Its age", "Its initial mass", "Its chemical composition", "Its rotation speed"],
            correctAnswerIndex: 1
        },
        {
            question: "What is a 'metal' in astronomical terms?",
            options: ["Any shiny element", "Elements heavier than helium", "Elements found on metallic planets", "Only iron and nickel"],
            correctAnswerIndex: 1
        },
        {
            question: "What is the name of the diagram that plots stars' luminosity against their temperature?",
            options: ["Hubble Diagram", "Hertzsprung-Russell (H-R) Diagram", "Newtonian Chart", "Kepler's Grid"],
            correctAnswerIndex: 1
        },
        {
            question: "Approximately how much of a star's lifetime is spent on the main sequence?",
            options: ["10%", "50%", "75%", "90%"],
            correctAnswerIndex: 3
        },
        {
            question: "What is the primary 'fuel' that protostars primarily collect before fusion begins?",
            options: ["Oxygen", "Carbon", "Hydrogen", "Iron"],
            correctAnswerIndex: 2
        },
        {
            question: "What force causes molecular clouds to collapse and form protostars?",
            options: ["Electromagnetism", "Nuclear force", "Gravity", "Friction"],
            correctAnswerIndex: 2
        },
        {
            question: "When a star becomes a red giant, what new element begins to fuse in its core?",
            options: ["Hydrogen", "Helium", "Iron", "Silicon"],
            correctAnswerIndex: 1
        },
        {
            question: "What is the remnant of a high-mass star after a supernova explosion?",
            options: ["White dwarf or planetary nebula", "Red giant or protostar", "Neutron star or black hole", "Molecular cloud or main sequence star"],
            correctAnswerIndex: 2
        },
        {
            question: "What is the term for the process by which a star changes over time, governed primarily by its initial mass?",
            options: ["Cosmic expansion", "Galactic drift", "Stellar evolution", "Planetary formation"],
            correctAnswerIndex: 2
        }
    ];

    // Star evolution stages for the background star graphic
    const starEvolutionStages = [
        {
            name: "Nebula",
            scoreThreshold: 0,
            draw: (ctx, centerX, centerY, baseSize) => {
                ctx.save();
                ctx.globalAlpha = 0.5; // Moderately visible
                // Large, swirling cloud with multiple colors
                const colorStops = [
                    { offset: 0, color: 'rgba(100, 100, 150, 0.4)' }, // Blue-purple center
                    { offset: 0.3, color: 'rgba(50, 50, 100, 0.3)' },
                    { offset: 0.6, color: 'rgba(150, 80, 200, 0.2)' }, // Magenta swirl
                    { offset: 0.8, color: 'rgba(80, 120, 180, 0.1)' }, // Lighter blue
                    { offset: 1, color: 'transparent' }
                ];

                for (let i = 0; i < 3; i++) {
                    const gradient = ctx.createRadialGradient(centerX + Math.sin(Date.now() * 0.0001 * (i + 1)) * baseSize,
                                                               centerY + Math.cos(Date.now() * 0.0001 * (i + 1)) * baseSize,
                                                               baseSize * 0.5, centerX, centerY, baseSize * (4 + i));
                    colorStops.forEach(stop => gradient.addColorStop(stop.offset, stop.color));
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, baseSize * (4 + i), 0, Math.PI * 2);
                    ctx.fill();
                }

                // Brighter, denser core forming (protostar hint)
                const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, baseSize * 1.5);
                coreGradient.addColorStop(0, 'rgba(255, 200, 0, 0.1)'); // Faint yellow glow
                coreGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, baseSize * 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        },
        {
            name: "Main Sequence Star",
            scoreThreshold: 50,
            draw: (ctx, centerX, centerY, baseSize) => {
                ctx.save();
                ctx.globalAlpha = 1; // Fully visible
                // Bright white/yellow star with a strong, distinct corona
                const starRadius = baseSize * 1.5;
                const coronaRadius = baseSize * 2.5;

                // Corona/Glow
                const coronaGradient = ctx.createRadialGradient(centerX, centerY, starRadius, centerX, centerY, coronaRadius);
                coronaGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)'); // White hot
                coronaGradient.addColorStop(0.3, 'rgba(255, 255, 200, 0.5)'); // Light yellow
                coronaGradient.addColorStop(0.7, 'rgba(255, 200, 0, 0.3)'); // Orange tint
                coronaGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = coronaGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, coronaRadius, 0, Math.PI * 2);
                ctx.fill();

                // Star body
                ctx.fillStyle = '#FFFF00'; // Solid yellow core
                ctx.beginPath();
                ctx.arc(centerX, centerY, starRadius, 0, Math.PI * 2);
                ctx.fill();

                // Center highlight
                const highlightGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, starRadius * 0.5);
                highlightGradient.addColorStop(0, '#FFFFFF');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = highlightGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, starRadius * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        },
        {
            name: "Red Giant",
            scoreThreshold: 100,
            draw: (ctx, centerX, centerY, baseSize) => {
                ctx.save();
                ctx.globalAlpha = 0.8; // Large and somewhat diffuse
                // Very large, reddish star with distinct, expanding outer layers
                const coreRadius = baseSize * 1.8;
                const outerLayerRadius = baseSize * 4;

                // Outer, diffuse layer
                const outerGradient = ctx.createRadialGradient(centerX, centerY, coreRadius, centerX, centerY, outerLayerRadius);
                outerGradient.addColorStop(0, 'rgba(255, 100, 0, 0.5)'); // Deep orange
                outerGradient.addColorStop(0.5, 'rgba(255, 50, 0, 0.3)'); // Redder
                outerGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = outerGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerLayerRadius, 0, Math.PI * 2);
                ctx.fill();

                // Inner, denser core
                const innerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreRadius);
                innerGradient.addColorStop(0, '#FF4500'); // OrangeRed
                innerGradient.addColorStop(1, '#FF6347'); // Tomato
                ctx.fillStyle = innerGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, coreRadius, 0, Math.PI * 2);
                ctx.fill();

                // Faint pulsating atmosphere effect
                ctx.fillStyle = `rgba(255, 100, 0, ${0.1 + Math.sin(Date.now() * 0.005) * 0.05})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerLayerRadius * (1.05 + Math.sin(Date.now() * 0.002) * 0.02), 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        },
        {
            name: "Supernova",
            scoreThreshold: 150,
            draw: (ctx, centerX, centerY, baseSize) => {
                ctx.save();
                ctx.globalAlpha = 1; // Full opacity for the explosion
                // Brilliant, expanding flash with strong radial streaks and shockwaves
                const flashRadius = baseSize * 2.5 + Math.sin(gameState.supernovaFlashTimer * 0.1) * baseSize * 2; // Pulsating size
                const currentAlpha = gameState.supernovaFlashTimer / 90; // Fade out over 90 frames (1.5 seconds)

                // Main explosion core
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, flashRadius);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${currentAlpha})`);
                gradient.addColorStop(0.2, `rgba(255, 200, 0, ${currentAlpha * 0.9})`);
                gradient.addColorStop(0.5, `rgba(255, 69, 0, ${currentAlpha * 0.6})`); // OrangeRed
                gradient.addColorStop(0.8, `rgba(255, 0, 0, ${currentAlpha * 0.3})`);
                gradient.addColorStop(1, `rgba(255, 0, 0, 0)`); // Transparent red
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, flashRadius, 0, Math.PI * 2);
                ctx.fill();

                // Add intense starburst effect (radial lines)
                ctx.strokeStyle = `rgba(255, 255, 255, ${currentAlpha * 0.8})`;
                ctx.lineWidth = 1 + currentAlpha * 3; // Wider lines for more intensity
                for (let i = 0; i < 360; i += 10) { // More lines
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    const angle = (i * Math.PI / 180) + (gameState.supernovaFlashTimer * 0.08); // Faster spin effect
                    const endX = centerX + Math.cos(angle) * flashRadius * 1.5; // Longer lines
                    const endY = centerY + Math.sin(angle) * flashRadius * 1.5;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }

                // Secondary shockwave pulse
                if (currentAlpha > 0.2) {
                    const shockwaveRadius = flashRadius * (1.2 + (1 - currentAlpha) * 0.5);
                    ctx.strokeStyle = `rgba(255, 200, 0, ${currentAlpha * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, shockwaveRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            }
        },
        {
            name: "Black Hole",
            scoreThreshold: 200,
            draw: (ctx, centerX, centerY, baseSizeParam) => { // baseSizeParam is now currentBlackHoleDisplaySize
                ctx.save();
                ctx.globalAlpha = 0.95;

                // Use the passed baseSizeParam as the current black hole size
                const currentBlackHoleSize = baseSizeParam;

                // Event Horizon (sharp, dark core)
                ctx.fillStyle = '#000000'; // Pure black
                ctx.beginPath();
                ctx.arc(centerX, centerY, currentBlackHoleSize, 0, Math.PI * 2); // Use dynamic size
                ctx.fill();

                // Accretion disk (vibrant, rotating ring)
                // Adjust ring size relative to currentBlackHoleSize
                const ringInner = currentBlackHoleSize * 0.7;
                const ringOuter = currentBlackHoleSize * 1.5;

                const ringGradient = ctx.createRadialGradient(centerX, centerY, ringInner, centerX, centerY, ringOuter);
                ringGradient.addColorStop(0, 'rgba(255, 250, 200, 0.0)');
                ringGradient.addColorStop(0.2, 'rgba(255, 250, 200, 0.8)');
                ringGradient.addColorStop(0.5, 'rgba(255, 140, 0, 0.6)');
                ringGradient.addColorStop(0.8, 'rgba(255, 69, 0, 0.4)');
                ringGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = ringGradient;

                ctx.beginPath();
                ctx.arc(centerX, centerY, ringOuter, 0, Math.PI * 2);
                ctx.fill();

                // Accretion disk rotation effect
                // Apply rotation only to the disk itself for visual flair
                ctx.translate(centerX, centerY);
                ctx.rotate(gameState.blackHoleRotation);
                ctx.translate(-centerX, -centerY);


                ctx.restore(); // Restore global alpha and transforms
            }
        }
    ];

    // Input handling
    const keys = {};

    document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });

    // Initialize stars background
    function initStars() {
        gameState.stars = [];
        for (let i = 0; i < 100; i++) {
            gameState.stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                brightness: Math.random() * 0.5 + 0.5
            });
        }
    }

    // Create particles based on current stage
    function createParticles() {
        // Clear old particles occasionally
        if (Math.random() < 0.1) {
            gameState.particles = gameState.particles.filter(p => p.x > -50);
        }

        // Add new particles
        if (Math.random() < 0.3) {
            let particle = {
                x: canvas.width + 10,
                y: Math.random() * canvas.height,
                vx: -1.5 - Math.random() * 2.5, // Slightly lowered particle speed
                vy: (Math.random() - 0.5) * 2,
                size: Math.random() * 3 + 2,
                type: 'gas'
            };

            if (gameState.currentStage >= 2) {
                particle.color = Math.random() < 0.5 ? '#ffaa00' : '#ff6600'; // fusion glow
            } else {
                particle.color = Math.random() < 0.5 ? '#6666aa' : '#4488aa'; // gas/dust
            }

            gameState.particles.push(particle);
        }
    }

    // Create collectibles (elements)
    function createCollectibles() {
        if (Math.random() < 0.02) {
            let collectible = {
                x: canvas.width + 10,
                y: Math.random() * (canvas.height - 100) + 50,
                size: 8,
                collected: false,
                type: 'element',
                pulse: 0
            };

            // Different elements based on stage
            if (gameState.currentStage <= 1) {
                collectible.color = '#00ff88';
                collectible.name = 'H/He';
            } else if (gameState.currentStage <= 3) {
                collectible.color = '#ffaa00';
                collectible.name = 'C/O';
            } else {
                collectible.color = '#ff6644';
                collectible.name = 'Heavy';
            }

            gameState.collectibles.push(collectible);
        }
    }

    // Create obstacles
    function createObstacles() {
        if (Math.random() < 0.01) { // Increased spawn rate slightly for more variety
            let obstacle = {
                x: canvas.width + 10,
                y: Math.random() * (canvas.height - 100) + 50,
                size: 15 + Math.random() * 10,
                vx: -1.5 - Math.random() * 1.5, // Slightly lowered obstacle speed
                quizTriggered: false
            };

            // Randomly choose obstacle type
            const obstacleTypeRoll = Math.random();
            if (obstacleTypeRoll < 0.4) { // 40% chance for existing types
                if (gameState.currentStage === 3) {
                    obstacle.type = 'stellarWind';
                    obstacle.color = '#ff4444';
                    obstacle.name = 'Stellar Wind';
                    obstacle.size = 20 + Math.random() * 15; // Larger
                } else if (gameState.currentStage >= 4) {
                    obstacle.type = 'debris';
                    obstacle.color = '#aa4444';
                    obstacle.name = 'Cosmic Debris';
                    obstacle.size = 20 + Math.random() * 15; // Larger
                } else {
                    obstacle.type = 'dust';
                    obstacle.color = '#666666';
                    obstacle.name = 'Dense Matter';
                }
            } else if (obstacleTypeRoll < 0.7) { // 30% chance for asteroid
                obstacle.type = 'asteroid';
                obstacle.color = '#8B4513'; // Brownish color
                obstacle.name = 'Asteroid';
                obstacle.size = 18 + Math.random() * 12; // Medium size
            } else { // 30% chance for meteor
                obstacle.type = 'meteor';
                obstacle.color = '#4F4F4F'; // Dark grey
                obstacle.name = 'Meteor';
                obstacle.size = 12 + Math.random() * 8; // Smaller, faster
                obstacle.vx = -2.5 - Math.random() * 1.5; // Adjusted meteor speed
            }

            gameState.obstacles.push(obstacle);
        }
    }

    // Update player position
    function updatePlayer() {
        const player = gameState.player;

        // Handle input
        if (keys['w'] || keys['arrowup']) player.y -= player.speed;
        if (keys['s'] || keys['arrowdown']) player.y += player.speed;
        if (keys['a'] || keys['arrowleft']) player.x -= player.speed;
        if (keys['d'] || keys['arrowright']) player.x += player.speed;

        // Keep player in bounds
        player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
        player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));

        // Slight rotation based on movement
        if (keys['w'] || keys['arrowup']) player.angle = -0.1;
        else if (keys['s'] || keys['arrowdown']) player.angle = 0.1;
        else player.angle *= 0.9;
    }

    // Update particles
    function updateParticles() {
        gameState.particles.forEach(particle => {
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Add some drift
            particle.vy += (Math.random() - 0.5) * 0.1;
            particle.vy *= 0.99;
        });

        gameState.particles = gameState.particles.filter(p => p.x > -50);
    }

    // Update collectibles
    function updateCollectibles() {
        gameState.collectibles.forEach(collectible => {
            collectible.x -= 1.5; // Slightly lowered speed
            collectible.pulse += 0.2;

            // Check collision with player
            const dx = collectible.x - (gameState.player.x + gameState.player.width/2);
            const dy = collectible.y - (gameState.player.y + gameState.player.height/2);
            const distance = Math.sqrt(dx*dx + dy*dy);

            if (distance < collectible.size + 10 && !collectible.collected) {
                collectible.collected = true;
                gameState.score += 10;
                gameState.elements++;
            }
        });

        gameState.collectibles = gameState.collectibles.filter(c => c.x > -20 && !c.collected);
    }

    // Update obstacles
    function updateObstacles() {
        gameState.obstacles.forEach(obstacle => {
            obstacle.x += obstacle.vx;

            // Check collision with player
            const dx = obstacle.x - (gameState.player.x + gameState.player.width/2);
            const dy = obstacle.y - (gameState.player.y + gameState.player.height/2);
            const distance = Math.sqrt(dx*dx + dy*dy);

            // Collision detection for damage/push back
            if (distance < obstacle.size + 15) {
                gameState.player.x -= 20;
                gameState.score = Math.max(0, gameState.score - 5);

                // Trigger quiz only if it's a "danger" obstacle and hasn't triggered a quiz yet
                if (!gamePaused && !obstacle.quizTriggered &&
                    (obstacle.type === 'stellarWind' || obstacle.type === 'debris' ||
                     obstacle.type === 'asteroid' || obstacle.type === 'meteor')) {
                    showQuestion();
                    obstacle.quizTriggered = true; // Mark this obstacle as having triggered a quiz
                }
            }
        });

        // Filter out obstacles that have gone off-screen
        gameState.obstacles = gameState.obstacles.filter(o => o.x > -50);
    }

    // Update stage progression for game stages (not background star evolution)
    function updateStage() {
        gameState.stageProgress++;

        // The current game stage (related to collectible/obstacle types)
        const currentStageData = stages[gameState.currentStage];
        const progress = (gameState.stageProgress / currentStageData.duration) * 100;

        if (gameState.stageProgress >= currentStageData.duration) {
            if (gameState.currentStage < stages.length - 1) {
                gameState.currentStage++;
                gameState.stageProgress = 0;
                gameState.score += 50; // Stage completion bonus
            }
        }

        // Update UI progress bar (always uses the standard game stages)
        document.getElementById('stageProgress').style.width = Math.min(progress, 100) + '%';
    }


    // Draw functions
    function drawStars() {
        ctx.fillStyle = stages[gameState.currentStage].starColor;
        gameState.stars.forEach(star => {
            ctx.globalAlpha = star.brightness;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        });
        ctx.globalAlpha = 1;
    }

    function drawParticles() {
        gameState.particles.forEach(particle => {
            ctx.fillStyle = particle.color;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    }

    function drawPlayer() {
        const player = gameState.player;
        const centerX = player.x + player.width / 2;
        const centerY = player.y + player.height / 2;

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(player.angle);

        // Main Body (more sleek)
        ctx.fillStyle = '#00aaff'; /* Blue spaceship */
        ctx.beginPath();
        ctx.moveTo(-player.width / 2, 0); // Left point
        ctx.lineTo(player.width / 2, -player.height / 4); // Top-right wing start
        ctx.lineTo(player.width / 2, player.height / 4); // Bottom-right wing start
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Top fin
        ctx.beginPath();
        ctx.moveTo(0, -player.height / 2);
        ctx.lineTo(player.width / 4, -player.height / 4);
        ctx.lineTo(player.width / 4, player.height / 4);
        ctx.lineTo(0, player.height / 2);
        ctx.closePath();
        ctx.fill();

        // Cockpit (more distinct)
        ctx.fillStyle = '#66ddff'; /* Lighter blue for cockpit */
        ctx.beginPath();
        ctx.arc(player.width / 4, 0, player.height / 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#0088ff';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Engine Thrusters (multiple with exhaust)
        const exhaustColor = '#ff8800'; // Orange exhaust
        const numEngines = 2;
        const engineSpacing = player.height / (numEngines + 1);
        for (let i = 0; i < numEngines; i++) {
            const engineY = -player.height / 2 + engineSpacing * (i + 1);
            ctx.fillStyle = '#333'; // Darker for engine casing
            ctx.fillRect(-player.width / 2 - 5, engineY - 5, 10, 10);

            // Exhaust flame
            ctx.fillStyle = exhaustColor;
            ctx.beginPath();
            ctx.moveTo(-player.width / 2 - 5, engineY - 3);
            ctx.lineTo(-player.width / 2 - 15 - Math.random() * 5, engineY); // Flickering effect
            ctx.lineTo(-player.width / 2 - 5, engineY + 3);
            ctx.closePath();
            ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.01) * 0.2; // Pulsing alpha
            ctx.fill();
            ctx.globalAlpha = 1; // Reset alpha
        }

        ctx.restore();
    }


    function drawCollectibles() {
        gameState.collectibles.forEach(collectible => {
            const glowSize = collectible.size + Math.sin(collectible.pulse) * 3;

            // Glow effect
            ctx.fillStyle = collectible.color + '44';
            ctx.beginPath();
            ctx.arc(collectible.x, collectible.y, glowSize, 0, Math.PI * 2);
            ctx.fill();

            // Core
            ctx.fillStyle = collectible.color;
            ctx.beginPath();
            ctx.arc(collectible.x, collectible.y, collectible.size, 0, Math.PI * 2);
            ctx.fill();

            // Label
            ctx.fillStyle = 'white';
            ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(collectible.name, collectible.x, collectible.y - collectible.size - 5);
        });
    }

    function drawObstacles() {
        gameState.obstacles.forEach(obstacle => {
            if (obstacle.type === 'asteroid') {
                // Draw irregular asteroid shape
                ctx.fillStyle = obstacle.color;
                ctx.strokeStyle = '#603310'; // Darker border
                ctx.lineWidth = 2;
                ctx.beginPath();
                const numSides = Math.floor(Math.random() * 3) + 5; // 5 to 7 sides
                for (let i = 0; i < numSides; i++) {
                    const angle = (i / numSides) * Math.PI * 2;
                    const radius = obstacle.size * (0.8 + Math.random() * 0.4); // Irregularity
                    const x = obstacle.x + Math.cos(angle) * radius;
                    const y = obstacle.y + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Add some darker spots/craters for detail
                ctx.fillStyle = '#5C2F0A';
                ctx.beginPath();
                ctx.arc(obstacle.x + obstacle.size * 0.3, obstacle.y - obstacle.size * 0.2, obstacle.size * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(obstacle.x - obstacle.size * 0.4, obstacle.y + obstacle.size * 0.3, obstacle.size * 0.15, 0, Math.PI * 2);
                ctx.fill();

            } else if (obstacle.type === 'meteor') {
                // Draw meteor with fiery trail
                ctx.fillStyle = obstacle.color; // Meteor body
                ctx.beginPath();
                ctx.arc(obstacle.x, obstacle.y, obstacle.size, 0, Math.PI * 2);
                ctx.fill();

                // Fiery trail
                const trailLength = obstacle.size * 3;
                const trailGradient = ctx.createLinearGradient(obstacle.x + obstacle.size, obstacle.y, obstacle.x + obstacle.size + trailLength, obstacle.y);
                trailGradient.addColorStop(0, 'rgba(255, 140, 0, 0.8)'); // Orange
                trailGradient.addColorStop(0.5, 'rgba(255, 69, 0, 0.6)'); // Red-orange
                trailGradient.addColorStop(1, 'rgba(255, 0, 0, 0)'); // Transparent red

                ctx.fillStyle = trailGradient;
                ctx.beginPath();
                ctx.moveTo(obstacle.x + obstacle.size, obstacle.y - obstacle.size / 2);
                ctx.lineTo(obstacle.x + obstacle.size + trailLength, obstacle.y);
                ctx.lineTo(obstacle.x + obstacle.size, obstacle.y + obstacle.size / 2);
                ctx.closePath();
                ctx.fill();

                // Radiative heat glow (subtle)
                const glowGradient = ctx.createRadialGradient(obstacle.x, obstacle.y, 0, obstacle.x, obstacle.y, obstacle.size * 1.5);
                glowGradient.addColorStop(0, obstacle.color + 'FF');
                glowGradient.addColorStop(0.7, obstacle.color + '44');
                glowGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(obstacle.x, obstacle.y, obstacle.size * 1.5, 0, Math.PI * 2);
                ctx.fill();

            } else {
                // Existing obstacle drawing logic
                ctx.fillStyle = obstacle.color;
                ctx.beginPath();
                ctx.arc(obstacle.x, obstacle.y, obstacle.size, 0, Math.PI * 2);
                ctx.fill();

                // Warning glow (only for existing types)
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });
    }

    // Function to draw the evolving central star
    function drawCentralStar() {
        const centerX = canvas.width * 0.85; // Position further to the right
        const centerY = canvas.height * 0.5;
        let baseStarSize = 70; // Base size for the background star (initial for any star type)

        // For Black Hole stage, calculate dynamic size
        if (starEvolutionStages[gameState.starEvolutionStage].name === "Black Hole") {
            const minScoreForGrowth = starEvolutionStages[4].scoreThreshold; // 200
            const maxScoreForFullGameEnd = 500; // When it covers the screen
            const initialBlackHoleCoreRadius = baseStarSize * 0.6; // Black hole core starts at a fraction of baseSize

            let currentBlackHoleDisplaySize = initialBlackHoleCoreRadius;

            if (gameState.score >= minScoreForGrowth) {
                const scoreProgress = gameState.score - minScoreForGrowth;
                const totalGrowthPoints = maxScoreForFullGameEnd - minScoreForGrowth; // 300 points
                // Target radius needs to cover the canvas for "Game Over" effect
                const targetMaxRadius = Math.max(canvas.width, canvas.height) * 0.7; // Target 70% of max dimension to "envelope"

                if (totalGrowthPoints > 0) {
                    const growthRatePerPoint = (targetMaxRadius - initialBlackHoleCoreRadius) / totalGrowthPoints;
                    currentBlackHoleDisplaySize = initialBlackHoleCoreRadius + (scoreProgress * growthRatePerPoint);
                }
                currentBlackHoleDisplaySize = Math.min(currentBlackHoleDisplaySize, targetMaxRadius);
            }
            // Pass this dynamically calculated size for the black hole drawing
            starEvolutionStages[gameState.starEvolutionStage].draw(ctx, centerX, centerY, currentBlackHoleDisplaySize);

            // Check for game over (black hole consumes screen)
            if (currentBlackHoleDisplaySize >= Math.max(canvas.width, canvas.height) * 0.65 && !gamePaused) { // Trigger slightly before full screen
                showGameOver();
            }

        } else if (gameState.supernovaFlashTimer > 0) {
            // Find the supernova stage by name
            const supernovaStage = starEvolutionStages.find(s => s.name === "Supernova");
            if (supernovaStage) {
                supernovaStage.draw(ctx, centerX, centerY, baseStarSize); // Supernova still uses baseSize
            }
        } else {
            // Otherwise, draw the current star evolution stage using its regular baseSize
            starEvolutionStages[gameState.starEvolutionStage].draw(ctx, centerX, centerY, baseStarSize);
        }
    }

    // Quiz System Functions
    const questionModal = document.getElementById('questionModal');
    const questionText = document.getElementById('questionText');
    const answerOptionsContainer = document.getElementById('answerOptions');
    const feedbackText = document.getElementById('feedbackText');

    let currentQuestion = null;

    function showQuestion() {
        gamePaused = true;
        // Select a random question from the expanded list
        currentQuestion = questions[Math.floor(Math.random() * questions.length)];

        questionText.textContent = currentQuestion.question;
        answerOptionsContainer.innerHTML = ''; // Clear previous options
        feedbackText.textContent = '';
        feedbackText.className = 'feedback-message';

        currentQuestion.options.forEach((option, index) => {
            const button = document.createElement('button');
            button.textContent = option;
            button.addEventListener('click', () => selectAnswer(index));
            answerOptionsContainer.appendChild(button);
        });

        questionModal.classList.add('active'); // Show modal
    }

    function selectAnswer(selectedIndex) {
        const buttons = answerOptionsContainer.querySelectorAll('button');
        const isCorrect = selectedIndex === currentQuestion.correctAnswerIndex;

        buttons.forEach((button, index) => {
            button.disabled = true; // Disable all buttons after selection
            if (index === currentQuestion.correctAnswerIndex) {
                button.classList.add('correct');
            } else if (index === selectedIndex) {
                button.classList.add('incorrect');
            }
        });

        if (isCorrect) {
            feedbackText.textContent = "Correct! Well done!";
            feedbackText.classList.add('correct-feedback');
            gameState.score += 20; // Bonus for correct answer
        } else {
            feedbackText.textContent = "Incorrect. The correct answer was: " + currentQuestion.options[currentQuestion.correctAnswerIndex];
            feedbackText.classList.add('incorrect-feedback');
        }

        // Wait a moment before hiding the question and resuming the game
        setTimeout(() => {
            hideQuestion();
        }, 2000); // Display feedback for 2 seconds
    }

    function hideQuestion() {
        questionModal.classList.remove('active'); // Hide modal
        gamePaused = false; // Resume game
    }

    // Game Over System
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreSpan = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');

    function showGameOver() {
        gamePaused = true;
        finalScoreSpan.textContent = gameState.score;
        gameOverModal.classList.add('active');
    }

    restartButton.addEventListener('click', restartGame);

    function restartGame() {
        // Reset game state
        gameState = {
            score: 0,
            elements: 0,
            currentStage: 0,
            stageProgress: 0,
            player: {
                x: 100,
                y: canvas.height / 2,
                width: 40,
                height: 30,
                speed: 3.5, // Reset to new lowered speed
                angle: 0
            },
            particles: [],
            collectibles: [],
            obstacles: [],
            stars: [],
            starEvolutionStage: 0,
            supernovaFlashTimer: 0,
            blackHoleRotation: 0,
            lastStarEvolutionScoreTier: -1
        };

        // Re-initialize elements
        initStars();
        gameState.particles = [];
        gameState.collectibles = [];
        gameState.obstacles = [];

        // Hide modal and resume game
        gameOverModal.classList.remove('active');
        gamePaused = false;
        // The gameLoop will naturally continue when gamePaused is false
    }


    // Main game loop
    function gameLoop() {
        if (!gamePaused) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background stars (twinkling)
            drawStars();

            // Draw the evolving background star (drawn before other elements)
            drawCentralStar();

            // Update game state
            updatePlayer();
            updateParticles();
            updateCollectibles();
            updateObstacles(); // Obstacles now handle quiz trigger
            updateStage();

            // Create new objects
            createParticles();
            createCollectibles();
            createObstacles();

            // --- Update background star evolution based on score ---
            const currentScoreTier = Math.floor(gameState.score / 50);

            if (currentScoreTier !== gameState.lastStarEvolutionScoreTier) {
                // Determine the target stage based on the current score tier
                let targetStageIndex = 0; // Default to Nebula (score 0-49)
                if (currentScoreTier >= 1) { // 50+ score
                    targetStageIndex = 1; // Main Sequence (score 50-99)
                }
                if (currentScoreTier >= 2) { // 100+ score
                    targetStageIndex = 2; // Red Giant (score 100-149)
                }
                if (currentScoreTier >= 3) { // 150+ score
                    targetStageIndex = 3; // Supernova (score 150-199)
                }
                if (currentScoreTier >= 4) { // 200+ score
                    targetStageIndex = 4; // Black Hole (score 200+)
                }

                // Only update if the target stage is different
                if (targetStageIndex !== gameState.starEvolutionStage) {
                    gameState.starEvolutionStage = targetStageIndex;
                    gameState.lastStarEvolutionScoreTier = currentScoreTier; // Update tier
                    // Special handling for Supernova visual trigger
                    if (starEvolutionStages[gameState.starEvolutionStage].name === "Supernova") {
                        gameState.supernovaFlashTimer = 90; // Flash for 1.5 seconds (60 FPS * 1.5)
                    }
                }
            }


            // Decrement supernova flash timer if active
            if (gameState.supernovaFlashTimer > 0) {
                gameState.supernovaFlashTimer--;
                // If timer runs out during supernova stage, and we're past its score threshold,
                // automatically transition to Black Hole if not already there.
                if (gameState.supernovaFlashTimer === 0 && starEvolutionStages[gameState.starEvolutionStage].name === "Supernova") {
                    const blackHoleStage = starEvolutionStages.find(s => s.name === "Black Hole");
                    if (blackHoleStage && gameState.score >= blackHoleStage.scoreThreshold) { // Use its own threshold
                         gameState.starEvolutionStage = starEvolutionStages.indexOf(blackHoleStage);
                    }
                }
            }

            // Update black hole rotation
            if (starEvolutionStages[gameState.starEvolutionStage].name === "Black Hole") {
                gameState.blackHoleRotation += 0.005; // Continuously rotate accretion disk
            }
        }

        // Draw active game elements (drawn after the background star)
        drawParticles(); // Drawn again to ensure they are on top of the large star
        drawCollectibles();
        drawObstacles();
        drawPlayer();


        // Update UI: Use the relevant stage information for the info panel
        if (gameState.starEvolutionStage === 4) { // If black hole is visually active (index 4 in starEvolutionStages)
            document.getElementById('currentStage').textContent = stages[5].name; // Use the last stage entry from `stages` array (Black Hole)
            document.getElementById('stageTitle').textContent = stages[5].title;
            document.getElementById('stageDescription').textContent = stages[5].description;
        } else {
            // Otherwise, use the regular game stage progression info
            document.getElementById('currentStage').textContent = stages[gameState.currentStage].name;
            document.getElementById('stageTitle').textContent = stages[gameState.currentStage].title;
            document.getElementById('stageDescription').textContent = stages[gameState.currentStage].description;
        }

        // --- FIX: Update score and elements display ---
        document.getElementById('score').textContent = gameState.score;
        document.getElementById('elements').textContent = gameState.elements;


        requestAnimationFrame(gameLoop);
    }

    // Initialize and start game
    initStars();
    gameLoop();
</script>
</body>

</html>
